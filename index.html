<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slovenian Pop Typer: The Tree of Triglav</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto+Mono:wght@700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
            font-family: 'Roboto Mono', monospace;
            user-select: none;
        }

        /* UI Layers */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            color: white;
            pointer-events: none;
            z-index: 5;
            display: flex;
            justify-content: space-between;
            text-shadow: 2px 2px 0 #000;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 8px;
            border: 2px solid #fff;
        }

        h1, h2, h3 { margin: 0; }

        #timerDisplay { color: #ff5555; font-size: 1.5rem; }
        #scoreDisplay { color: #55ffff; font-size: 1.5rem; }

        /* Typing Bar */
        #typing-display {
            position: absolute;
            bottom: 40px;
            width: 100%;
            text-align: center;
            font-size: 3rem;
            color: #00ffcc;
            font-weight: bold;
            text-shadow: 0 0 15px #00ffcc;
            z-index: 5;
            pointer-events: none;
        }

        /* Fail/Funny Popup Text */
        #fail-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            color: #ff3333;
            font-weight: bold;
            text-shadow: 2px 2px 0 #fff;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 6;
            pointer-events: none;
            text-align: center;
        }

        /* Screens */
        #startScreen, #endScreen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(10, 10, 20, 0.95);
            color: white;
            z-index: 10;
        }

        .hidden { display: none !important; }

        input[type="text"] {
            padding: 15px;
            font-size: 1.2rem;
            border-radius: 5px;
            border: none;
            margin: 20px;
            text-align: center;
            font-family: 'Roboto Mono', monospace;
            width: 300px;
        }

        button {
            padding: 15px 40px;
            font-size: 1.2rem;
            background: linear-gradient(90deg, #00c6ff 0%, #0072ff 100%);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            color: white;
            font-weight: bold;
            text-transform: uppercase;
            margin-top: 10px;
            box-shadow: 0 0 15px rgba(0, 198, 255, 0.5);
            transition: transform 0.2s;
        }
        button:hover { transform: scale(1.05); }

        /* Scoreboard Table */
        table {
            border-collapse: collapse;
            margin-top: 20px;
            width: 80%;
            max-width: 600px;
            background: rgba(255,255,255,0.1);
        }
        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }
        th { color: #00ffcc; }
        .nickname { color: #ff00de; font-style: italic; font-size: 0.9rem; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="stat-box">SCORE: <span id="scoreDisplay">0</span></div>
        <div class="stat-box">TIME: <span id="timerDisplay">03:00</span></div>
    </div>

    <div id="fail-popup"></div>

    <div id="typing-display">
        <span id="currentInputText"></span><span style="animation:blink 1s infinite">_</span>
    </div>

    <div id="startScreen">
        <h1 style="color:#00ffcc; margin-bottom:10px;">SLOVENIAN HITS TYPER</h1>
        <p>Type Song + Artist to grow the tree.</p>
        <p>Phase 1: Slow | Phase 2: Fast | Phase 3: Chaos</p>
        
        <input type="text" id="playerNameInput" placeholder="Enter Your Name" maxlength="12">
        <button onclick="initGame()">Start Game</button>
        
        <h3>High Scores</h3>
        <table id="startScoreTable">
            </table>
    </div>

    <div id="endScreen" class="hidden">
        <h1 id="winnerText" style="color: gold; text-align:center; padding: 20px;"></h1>
        <h2 id="finalScoreText"></h2>
        <p id="playerIdentityDisplay"></p>
        <button onclick="resetGame()">Play Again</button>
        
        <h3>Leaderboard</h3>
        <table id="endScoreTable"></table>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // --- DATA: Slovenian Hits ---
        const rawHits = [
            {s: "Brizgalna Brizga", a: "Atomik Harmonik"},
            {s: "Ti si moj sonček", a: "Agropop"},
            {s: "Krokodilčki", a: "Čuki"},
            {s: "Pot v X", a: "Siddharta"},
            {s: "Soba 102", a: "Jan Plestenjak"},
            {s: "Od višine se zvrti", a: "Vlado Kreslin"},
            {s: "Silvija", a: "Magnifico"},
            {s: "Cela ulica nori", a: "Kingston"},
            {s: "Gorska Roža", a: "Andrej Šifrer"},
            {s: "Čebelar", a: "Lojze Slak"},
            {s: "Samo Ljubezen", a: "Sestre"},
            {s: "Maček Muri", a: "Neca Falk"},
            {s: "Greva dol", a: "Vlado Kreslin"},
            {s: "Platana", a: "Siddharta"},
            {s: "Lahko noč Piran", a: "Anika Horvat"},
            {s: "Bit", a: "Zmelkoow"},
            {s: "Siva Pot", a: "Aleksander Mežek"},
            {s: "Dan Ljubezni", a: "Pepel in Kri"},
            {s: "Jagode in čokolada", a: "Rok 'n' Band"},
            {s: "Mala Terasa", a: "Bele Vrane"},
            {s: "Daleč je za naju pomlad", a: "Adi Smolar"},
            {s: "Ne zameri mi", a: "Leeloojamais"},
            {s: "Voda", a: "Dan D"},
            {s: "Poletna noč", a: "Marjana Deržaj"},
            {s: "Zemlja pleše", a: "Videosex"},
            {s: "Moja Mama", a: "Big Foot Mama"},
            {s: "Hir aj kam", a: "Magnifico"},
            {s: "Na Soncu", a: "Siddharta"},
            {s: "Štajerska lady", a: "Kingston"},
            {s: "Komar", a: "Čuki"},
            {s: "Anita ni nikoli", a: "Šank Rock"},
            {s: "Tih deževen dan", a: "1X Band"},
            {s: "Mini maxi", a: "Be Pop"},
            {s: "Romeo in Julija", a: "Flirrt"},
            {s: "Pojdi z menoj", a: "Siddharta"},
            {s: "Nika", a: "Rock'n'Band"},
            {s: "Lačni fran", a: "Zoran Predin"},
            {s: "Ledena", a: "Siddharta"},
            {s: "Ti znaš", a: "Miran Rudan"},
            {s: "Ujel si se", a: "Tabu"}
        ];

        // --- DATA: Funny Texts ---
        const winnerQuotes = [
            "You type faster than a Bora wind!",
            "Triglav bows down to your skills!",
            "You are the Prešeren of Keyboards!",
            "Better than grandmother's Potica!",
            "Luka Dončić wishes he had your hands!",
            "You have conquered the Alps!",
            "Truly a legend of the Sava river!",
            "Even the Human Fish is impressed!",
            "King of the Hayrack!",
            "You shine brighter than Bled lake!",
            "Slovenia has a new hero!",
            "Faster than a Renault Twingo going downhill!",
            "You collected more points than mushrooms in autumn!",
            "Your fingers are national treasures!",
            "Martin Krpan could not do better!",
            "Absolute legend of Tivoli!",
            "The Dragons of Ljubljana respect you!",
            "Sweeter than Kremšnita!",
            "You are the true Kekec!",
            "Approved by the Ministry of Culture!"
        ];

        const failQuotes = [
            "Fingers like čevapčiči?",
            "Too much Cviček?",
            "Focus, Kekec!",
            "Did a bear scare you?",
            "Keyboard slipped?",
            "Too much Potica?",
            "Are you sleeping?",
            "Typing like a cow?",
            "Where is your rhythm?",
            "Need more coffee?"
        ];

        const nicknameSuffixes = [
            "The Potica Destroyer", "The Alpine Eagle", "The Soča Surfer", 
            "The Dragon Tamer", "The Cviček Connoisseur", "The Polka King/Queen", 
            "The Cave Dweller", "The Keyboard Accordionist", "The Winter Olympian", 
            "The Pumpkin Oil Baron"
        ];

        // --- Audio System ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            if (type === 'type') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.05);
                gain.gain.setValueAtTime(0.02, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.05);
                osc.start(now); osc.stop(now + 0.05);
            } else if (type === 'lock') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(440, now);
                osc.frequency.linearRampToValueAtTime(660, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'explode') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 0.3);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'fail') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.2);
                osc.start(now); osc.stop(now + 0.2);
            }
        }

        // --- Game Logic ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const timerDisplay = document.getElementById('timerDisplay');
        const inputDisplay = document.getElementById('currentInputText');
        const popup = document.getElementById('fail-popup');

        let width, height;
        let animationId;
        let score = 0;
        let timeLeft = 180; // 3 minutes
        let gameRunning = false;
        let currentInput = "";
        let playerName = "Player";
        let playerNickname = "";
        
        let spawnRate = 2000;
        let lastSpawn = 0;
        let words = [];
        let particles = [];
        let activeHits = []; // Copy of hits to remove from to avoid repeats
        let timerInterval;

        // High Score System
        function getHighScores() {
            return JSON.parse(localStorage.getItem('sloPopScores')) || [];
        }

        function saveHighScore(name, nick, score) {
            const scores = getHighScores();
            scores.push({ name, nick, score });
            scores.sort((a, b) => b.score - a.score);
            localStorage.setItem('sloPopScores', JSON.stringify(scores.slice(0, 10)));
        }

        function renderScoreTable(tableId) {
            const table = document.getElementById(tableId);
            const scores = getHighScores();
            table.innerHTML = `<tr><th>Name</th><th>Nickname</th><th>Score</th></tr>`;
            scores.forEach(s => {
                table.innerHTML += `<tr><td>${s.name}</td><td class="nickname">${s.nick}</td><td>${s.score}</td></tr>`;
            });
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();
        renderScoreTable('startScoreTable');

        // --- Classes ---

        class FloatingWord {
            constructor(text, pairId, type) {
                this.text = text;
                this.pairId = pairId;
                this.type = type;
                this.x = -Math.random() * 200 - 150;
                this.y = Math.random() * (height * 0.7) + 50;
                
                // Speed determined by Timer Phase
                let baseSpeed = 0.5;
                if (timeLeft < 120) baseSpeed = 1.2; // Phase 2
                if (timeLeft < 60) baseSpeed = 2.0;  // Phase 3
                
                this.speed = Math.random() * 1.0 + baseSpeed;
                this.size = 20;
                this.color = type === 'song' ? "#ff88ff" : "#88ffff";
                this.isPrimed = false;
            }

            update() {
                if (this.isPrimed) this.x += 0.2; // Slow down when waiting
                else this.x += this.speed;
            }

            draw(input) {
                ctx.font = `bold ${this.size}px 'Roboto Mono', monospace`;
                
                if (this.isPrimed) {
                    ctx.fillStyle = "#FFD700";
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = "orange";
                    ctx.fillText(this.text + " [WAITING]", this.x, this.y);
                    ctx.shadowBlur = 0;
                    return;
                }

                if (input.length > 0 && this.text.toLowerCase().startsWith(input.toLowerCase())) {
                    const matchPart = this.text.substring(0, input.length);
                    const restPart = this.text.substring(input.length);
                    
                    ctx.fillStyle = "#00ff00";
                    ctx.fillText(matchPart, this.x, this.y);
                    
                    ctx.fillStyle = this.color;
                    const w = ctx.measureText(matchPart).width;
                    ctx.fillText(restPart, this.x + w, this.y);
                    
                    ctx.fillRect(this.x, this.y+4, ctx.measureText(this.text).width, 2);
                } else {
                    ctx.fillStyle = this.color;
                    ctx.fillText(this.text, this.x, this.y);
                }
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                this.vx = (Math.random() - 0.5) * 12;
                this.vy = (Math.random() - 0.5) * 12;
                this.life = 1.0;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.life -= 0.04;
            }
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, 4, 4);
                ctx.globalAlpha = 1;
            }
        }

        // --- Core Functions ---

        function initGame() {
            const nameInput = document.getElementById('playerNameInput');
            if (nameInput.value.trim() === "") {
                alert("Please enter a name!");
                return;
            }
            playerName = nameInput.value;
            // Generate Random Nickname
            playerNickname = nicknameSuffixes[Math.floor(Math.random() * nicknameSuffixes.length)];
            
            startGame();
        }

        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('endScreen').classList.add('hidden');
            
            score = 0;
            timeLeft = 180; // 3 Minutes
            words = [];
            particles = [];
            currentInput = "";
            activeHits = [...rawHits]; // Clone list
            
            // Shuffle list
            activeHits.sort(() => Math.random() - 0.5);

            scoreDisplay.innerText = score;
            inputDisplay.innerText = "";
            gameRunning = true;
            
            // Start Timer
            clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);
            updateTimer(); // Initial call

            animate(0);
            if(audioCtx.state === 'suspended') audioCtx.resume();
        }

        function resetGame() {
            document.getElementById('endScreen').classList.add('hidden');
            document.getElementById('startScreen').classList.remove('hidden');
            renderScoreTable('startScoreTable');
        }

        function updateTimer() {
            if (!gameRunning) return;
            timeLeft--;
            
            // Format Time 00:00
            const m = Math.floor(timeLeft / 60);
            const s = timeLeft % 60;
            timerDisplay.innerText = `${m < 10 ? '0'+m : m}:${s < 10 ? '0'+s : s}`;

            // Adjust difficulty based on time
            if (timeLeft > 120) spawnRate = 2000; // Minute 1
            else if (timeLeft > 60) spawnRate = 1200; // Minute 2
            else spawnRate = 800; // Minute 3

            if (timeLeft <= 0) {
                endGame();
            }
        }

        function showFailPopup() {
            const phrase = failQuotes[Math.floor(Math.random() * failQuotes.length)];
            popup.innerText = phrase;
            popup.style.opacity = 1;
            playSound('fail');
            setTimeout(() => { popup.style.opacity = 0; }, 1000);
        }

        function spawnWordPair(timestamp) {
            if (timestamp - lastSpawn > spawnRate) {
                if (activeHits.length === 0) {
                    // Refill if empty, but highly unlikely in 3 mins
                    activeHits = [...rawHits]; 
                    activeHits.sort(() => Math.random() - 0.5);
                }

                const data = activeHits.pop(); // Take one off the stack
                const pairId = Date.now() + Math.random();

                const w1 = new FloatingWord(data.s, pairId, 'song');
                const w2 = new FloatingWord(data.a, pairId, 'artist');
                
                // Stagger spawn
                w2.x -= Math.random() * 150; 
                w2.y = Math.random() * (height * 0.7) + 50;

                words.push(w1, w2);
                lastSpawn = timestamp;
            }
        }

        // --- Interaction ---

        window.addEventListener('keydown', (e) => {
            if (!gameRunning) return;

            if (e.key === 'Backspace') {
                if (currentInput.length > 0) {
                    showFailPopup(); // Funny fail on correction
                }
                currentInput = "";
                inputDisplay.innerText = "";
                return;
            }

            if (e.key.length === 1 && !e.ctrlKey) {
                currentInput += e.key;
                inputDisplay.innerText = currentInput;
                playSound('type');
                checkMatch();
            }
        });

        function checkMatch() {
            // Find word exactly matching input that isn't already primed
            const matchIndex = words.findIndex(w => 
                w.text.toLowerCase() === currentInput.toLowerCase() && !w.isPrimed
            );

            if (matchIndex !== -1) {
                const matchedWord = words[matchIndex];
                matchedWord.isPrimed = true;
                currentInput = "";
                inputDisplay.innerText = "";
                
                const partnerIndex = words.findIndex(w => 
                    w.pairId === matchedWord.pairId && w !== matchedWord
                );

                if (partnerIndex !== -1 && words[partnerIndex].isPrimed) {
                    // COMBO
                    const partner = words[partnerIndex];
                    triggerExplosion(matchedWord);
                    triggerExplosion(partner);

                    words = words.filter(w => w.pairId !== matchedWord.pairId);
                    playSound('explode');
                    score += 10;
                    scoreDisplay.innerText = score;
                } else {
                    playSound('lock');
                }
            }
        }

        function triggerExplosion(obj) {
            const w = ctx.measureText(obj.text).width;
            const cx = obj.x + w/2;
            const cy = obj.y - 10;
            for(let i=0; i<15; i++) {
                particles.push(new Particle(cx, cy, obj.color));
            }
        }

        // --- Visuals ---

        function drawTree(startX, startY, len, angle, width, color) {
            ctx.beginPath();
            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.translate(startX, startY);
            ctx.rotate(angle * Math.PI / 180);
            ctx.moveTo(0, 0); ctx.lineTo(0, -len);
            ctx.stroke();

            if (len < 10) { ctx.restore(); return; }

            if (len < 15) {
                ctx.fillStyle = "#ff00de";
                ctx.beginPath();
                ctx.arc(0, -len, 4, 0, Math.PI*2);
                ctx.fill();
            }

            drawTree(0, -len, len * 0.75, angle + 20, width * 0.7, color);
            drawTree(0, -len, len * 0.75, angle - 20, width * 0.7, color);
            ctx.restore();
        }

        function drawSun(progress) {
            const sunY = height - (height * 0.85 * progress); 
            const grad = ctx.createLinearGradient(width/2, sunY-100, width/2, sunY+100);
            grad.addColorStop(0, "yellow");
            grad.addColorStop(1, "red");
            
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(width/2, sunY, 100, 0, Math.PI*2);
            ctx.fill();
        }

        function animate(timestamp) {
            if (!gameRunning) return;
            ctx.clearRect(0, 0, width, height);

            // Background based on Timer (Inverse of TimeLeft)
            const timeProgress = (180 - timeLeft) / 180;
            const r = 5 + (60 * timeProgress);
            const g = 5 + (80 * timeProgress);
            const b = 15 + (180 * timeProgress);
            document.body.style.backgroundColor = `rgb(${r},${g},${b})`;

            // Draw Sun based on Time
            drawSun(timeProgress);

            // Draw Tree based on SCORE (Growth)
            // Cap growth visually around 400 score
            const growthFactor = Math.min(score / 400, 1.2); 
            const treeLen = 50 + (150 * growthFactor);
            drawTree(width/2, height, treeLen, 0, 16, "#fff");

            spawnWordPair(timestamp);

            // Word Logic
            for (let i = words.length - 1; i >= 0; i--) {
                words[i].update();
                words[i].draw(currentInput);
                
                // Remove if off screen and penalize
                if (words[i].x > width + 50) {
                    showFailPopup();
                    // Remove both parts of the pair if one is missed
                    const pid = words[i].pairId;
                    words = words.filter(w => w.pairId !== pid);
                }
            }

            // Particle Logic
            particles.forEach((p, i) => {
                p.update();
                p.draw();
                if (p.life <= 0) particles.splice(i, 1);
            });

            animationId = requestAnimationFrame(animate);
        }

        function endGame() {
            gameRunning = false;
            clearInterval(timerInterval);

            // Save Score
            saveHighScore(playerName, playerNickname, score);

            // Setup End Screen
            const winnerQuote = winnerQuotes[Math.floor(Math.random() * winnerQuotes.length)];
            document.getElementById('winnerText').innerText = winnerQuote;
            document.getElementById('finalScoreText').innerText = "FINAL SCORE: " + score;
            document.getElementById('playerIdentityDisplay').innerText = `${playerName} - "${playerNickname}"`;
            
            renderScoreTable('endScoreTable');
            document.getElementById('endScreen').classList.remove('hidden');
        }

    </script>
</body>
</html>